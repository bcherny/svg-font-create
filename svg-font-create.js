// Generated by CoffeeScript 1.7.1
var DOMParser, SvgPath, config, convert, cssTemplate, defaults, execSync, fs, generate, glob, htmlTemplate, parse, path, rgxAcronym, rgxName, rgxUnicode, sassTemplate, svgTemplate, util, _;

fs = require('fs');

path = require('path');

_ = require('lodash');

DOMParser = (require('xmldom')).DOMParser;

glob = require('glob');

execSync = require('exec-sync');

SvgPath = require('svgpath');

util = require('./util');

defaults = require('./defaults.json');

config = require(path.resolve('./package.json'));

svgTemplate = util.loadTemplate('./templates/font.svg');

cssTemplate = util.loadTemplate('./templates/font.css');

sassTemplate = util.loadTemplate('./templates/_font.scss');

htmlTemplate = util.loadTemplate('./templates/font.html');

rgxUnicode = /([a-f][a-f\d]{3,4})/i;

rgxName = /-(.+).svg/;

rgxAcronym = /\b([\w\d])/ig;

parse = function(data, filename) {
  var doc, height, paths, polygons, svg, width;
  doc = (new DOMParser).parseFromString(data, 'application/xml');
  svg = _.first(doc.getElementsByTagName('svg'));
  height = parseFloat(svg.getAttribute('height'));
  width = parseFloat(svg.getAttribute('width'));
  if (isNaN(height)) {
    throw new Error("Missing height attribute in " + filename);
  }
  if (isNaN(width)) {
    throw new Error("Missing width attribute in " + filename);
  }
  paths = svg.getElementsByTagName('path');
  polygons = svg.getElementsByTagName('polygon');
  if (!paths.length && !polygons.length) {
    throw new Error("No path or polygon data found in " + filename);
  }
  return {
    height: height,
    width: width,
    d: "" + (util.compoundPathFromPaths(paths)) + " " + (util.compoundPathFromPolygons(polygons))
  };
};

generate = function(data) {
  var svg, ttf;
  svg = "" + data.font.output_dir + "/" + config.name + ".svg";
  ttf = "" + data.font.output_dir + "/" + config.name + ".ttf";
  return _.forEach({
    'Generating SVG': function() {
      return fs.writeFileSync(svg, svgTemplate(data), 'utf8');
    },
    'Generating TTF': function() {
      return execSync(path.resolve(__dirname, "./node_modules/.bin/svg2ttf " + svg + " " + ttf));
    },
    'Generating WOFF': function() {
      return execSync(path.resolve(__dirname, "./node_modules/.bin/ttf2woff " + ttf + " " + data.font.output_dir + "/" + config.name + ".woff"));
    },
    'Generating EOT': function() {
      return execSync(path.resolve(__dirname, "./node_modules/.bin/ttf2eot " + ttf + " " + data.font.output_dir + "/" + config.name + ".eot"));
    },
    'Generating CSS': function() {
      return fs.writeFileSync('./dist/font.css', cssTemplate(data), 'utf8');
    },
    'Generating SASS': function() {
      return fs.writeFileSync('./dist/_font.scss', sassTemplate(data), 'utf8');
    },
    'Generating HTML spec': function() {
      return fs.writeFileSync('./dist/font.html', htmlTemplate(data), 'utf8');
    },
    'Done!': function() {}
  }, function(fn, message) {
    console.log(message);
    return fn();
  });
};

convert = function(args) {
  var data, options;
  options = _.extend(defaults, config.font, args);
  data = {
    font: options,
    glyphs: [],
    fontHeight: options.ascent - options.descent,
    fontFamily: config.name,
    prefix: args.prefix || (config.name.match(rgxAcronym)).join(''),
    hex: util.hex()
  };
  console.log('Scaling images');
  glob.sync("" + args.input_dir + "/*.svg").forEach(function(file) {
    var glyph, name, ratio, unicode;
    name = _.first(file.match(rgxName));
    unicode = _.first(file.match(rgxUnicode));
    if (unicode == null) {
      throw new Error("Expected " + file + " to be in the format 'xxxx-icon-name.svg'");
    }
    glyph = parse(fs.readFileSync(file, 'utf8'), file);
    ratio = data.fontHeight / glyph.height;
    return data.glyphs.push({
      css: ((path.basename(name || unicode, '.svg')).replace(/-/g, ' ')).trim(),
      unicode: "&#x" + unicode + ";",
      width: glyph.width,
      d: (new SvgPath(glyph.d).scale(ratio, -ratio).toString)()
    });
  });
  return generate(data);
};

module.exports = convert;
